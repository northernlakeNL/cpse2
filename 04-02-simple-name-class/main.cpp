#include <iostream>
#include <memory>
#include <cstring>

namespace name1 {

	class name {
	public:
		char * p;

		name(const char * s) {
			p = new char[ std::strlen(s) + 1 ];
			std::strcpy(p, s);
		}

		// would be generated by the compiler 
		name(const name & rhs) :
			p{ rhs.p }
		{}

		~name() {
			delete[] p;
		}
	};

};

namespace name2 {

	class name {
	public:
		char * p;

		name( const char * s ) {
			p = new char[ std::strlen(s) + 1 ];
			std::strcpy(p, s);
		}

		name(const name & rhs) {
			p = new char[ std::strlen(rhs.p) + 1 ];
			std::strcpy( p, rhs.p );
		}

		~name() {
			delete[] p;
		}
	};

};

namespace name3 {

	class name {
	public:
		char * p;

		name(const char * s) {
			p = new char[ std::strlen(s) + 1 ];
			std::strcpy(p, s);
		}

		name( const name & rhs ) : name( rhs.p ) {}

		~name() {
			delete[] p;
		}
	};

};

namespace name4 {

	class name {
	public:
		char * p;

		name(const char * s) {
			p = new char[ std::strlen(s) + 1];
			std::strcpy(p, s);
		}

		name(const name & rhs) : name(rhs.p) {}

		// would be generated by the compiler 
		name & operator=(const name & rhs) {
			p = rhs.p;
			return *this;
		}

		~name() {
			delete[] p;
		}
	};

};

namespace name5 {

	class name {
	public:
		char * p;

		name(const char * s) {
			p = new char[ std::strlen(s) + 1];
			std::strcpy(p, s);
		}

		name(const name & rhs) : name(rhs.p) {}

		// naive assignment 
		name & operator=(const name & rhs) {
			delete[] p;
			p = new char[std::strlen(rhs.p) + 1];
			std::strcpy(p, rhs.p);
			return *this;
		}

		~name() {
			delete[] p;
		}
	};

};

namespace name6 {

	class name {
	public:
		char * p;

		name(const char * s) {
			p = new char[std::strlen(s) + 1];
			std::strcpy(p, s);
		}

		name(const name & rhs) : name(rhs.p) {}

		// save-old-pointer assignemnt
		name & operator=(const name & rhs) {
			auto old_p = p;
			auto rhs_p = rhs.p;
			p = new char[std::strlen(rhs_p) + 1];
			std::strcpy(p, rhs_p);
			delete[] old_p;
			return *this;
		}

		~name() {
			delete[] p;
		}
	};

};

namespace name7 {

	class name {
	public:
		char * p;

		name(const char * s) {
			p = new char[ std::strlen(s) + 1 ];
			strcpy(p, s);
		}

		name(const name & rhs) : name(rhs.p) {}

		// do-nothing assignment for self-assignment
		name & operator=(const name & rhs) {
			if (&rhs != this) {
				p = new char[strlen(rhs.p) + 1];
				std::strcpy(p, rhs.p);
				delete[] p;
			}
			return *this;
		}

		~name() {
			delete[] p;
		}
	};

};

namespace name8 {

	class name {
	private:
		std::unique_ptr< char[] > p;

	public:
		name(const char * s) {
			p = std::make_unique< char[] >( strlen(s) + 1 );
			std::strcpy( p.get(), s );
		}

		name(const name & rhs) : name( p.get() ) {}

		name & operator=(const name & rhs) {
           auto temp = new char[ std::strlen( rhs.p.get() ) + 1 ];
		   std::strcpy( temp, rhs.p.get() );
		   p.reset( temp );
		   return *this;
		}

        // no destructor needed
	};

};

using namespace name2;

int main() {
   name w( "Wouter" );
   name q( w );
   std::cout << w.p << " " << q.p << "\n";
   w.p[ 0 ] = 'J';
   std::cout << w.p << " " << q.p << "\n";
   return 0;
}